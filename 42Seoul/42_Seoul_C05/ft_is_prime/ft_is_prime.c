#include <stdio.h>

/*
	에라토스테네스의 체 라는 알고리즘.
	소수란, 기초 수학의 개념 중, 하나로써
	양의 약수를 오직 2개만 가지는 자연수를 의미한다.
	즉, 1과 자기 자신을 약수로 가지는 모든 자연수를 '소수'라 한다.
	ex.) 2, 3, 5, 6, 11, ...

	밑의 방식은 시간 복잡도가 O(N)으로, 모든 경우의 수를
	다 돌면서 여부를 확인한다는 점에서 몹시 비효율적이다.
*/

int ft_is_prime(int nb)
{
	int i;
	
	i = 2;
	if (nb <= 1)
		return 0;
	while (i < nb)
	{
		if (nb % i == 0)
			return 0;
		i++;
	}
	return 1;
}

int main()
{
	printf("%d", ft_is_prime(13));
	return 0;
}

/*
	O(N^(1/2))로 손쉽게 계산할 수 있다.
	모든 약수들은 대칭형태를 이루기에 해당 알고리즘이 가능하다.
	예를 들어, 8의 경우 약수가 1, 2, 4, 8로 총 네 가지가 존재하는데,
	이 때 1과 8을 제외하고 2와 4는 "2 * 4 = 4 * 2"와 같은 식으로
	대칭을 이루기에 특정한 숫자의 제곱근까지만 약수의 여부를 검증하면 계산이 된다.
	
	제곱근을 구하기 위해서 <math.h>해더파일을 이용한다.
	int end = (int) sqrt(x); 언제까지 확인할지, 제곱근 함수를 이용해서
	특정한 숫자의 제곱근까지만 나누어서 0이 되는지 약수 여부를 확인할 수 있다.

	bool isPrime(int x)
	{
		int end = (int) sqrt(x);
		for(int i = 2; i <= end; i++)
			if(x % i == 0) return false;
		return true;
	}
*/

/*
	한 두개가 아닌, 여러개의 소수를 한꺼번에 판별하고자 할 때는
	'에라토스테네스의 체'라는 알고리즘을 이용한다.
	가장 먼저 소수를 판별할 범위만큼 배열을 만들어 놓고,
	그 인덱스에 해당하는 값을 넣어주고, 이후에 한 개씩 지워나가는 방법을 이용한다.

	링크 유튜브 동빈나 : https://www.youtube.com/watch?v=5ypkoEgFdH8
*/